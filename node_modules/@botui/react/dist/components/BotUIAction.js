import React, { useEffect, useRef } from 'react';
import { BOTUI_BLOCK_TYPES } from 'botui';
import { defaultTexts } from '../const.js';
import { CSSClasses } from '../types.js';
import { useBotUI, useBotUIAction } from '../hooks/index.js';
import { BringIntoView, SlideFade, WithRefContext } from './Utils.js';
import { BotuiActionSelect, BotuiActionSelectButtons, } from './BotUIActionSelect.js';
import { BotUIButton, BotUICancelButton } from './Buttons.js';
export const BotUIWait = () => {
    return (React.createElement("div", { className: CSSClasses.botui_wait },
        React.createElement("i", { className: "loading_dot" }),
        React.createElement("i", { className: "loading_dot" }),
        React.createElement("i", { className: "loading_dot" })));
};
export const BotuiActionText = () => {
    const bot = useBotUI();
    const action = useBotUIAction();
    const meta = action?.meta;
    const inputRef = useRef(null);
    const textAreaRef = useRef(null);
    useEffect(() => {
        inputRef?.current?.focus?.();
        textAreaRef?.current?.focus?.();
    }, []);
    return (React.createElement("form", { onSubmit: (e) => {
            e.preventDefault();
            // not using a state and getting value to support unchanged-input-submission
            // and to avoid an extra onChange on input
            const value = textAreaRef?.current?.value ?? inputRef?.current?.value;
            bot.next({
                text: value,
                value: inputRef?.current?.files ?? value, // when type = 'file'
            });
        } },
        action?.data?.type === 'textarea' ? (React.createElement("textarea", { ref: textAreaRef, ...action?.data })) : (React.createElement("input", { type: "text", ref: inputRef, ...action?.data })),
        React.createElement(BotUIButton, { text: meta?.confirmButtonText ?? defaultTexts.buttons.confirm }),
        meta?.cancelable ? (React.createElement(BotUICancelButton, { ...meta, onClick: (cancelValue) => {
                bot.next({
                    value: null,
                    ...cancelValue
                });
            } })) : null));
};
const actionRenderers = {
    wait: BotUIWait,
    input: BotuiActionText,
    select: BotuiActionSelect,
    selectButtons: BotuiActionSelectButtons,
};
export function BotUIAction({ renderer = {}, bringIntoView = true, }) {
    const action = useBotUIAction();
    const actionType = action?.meta?.actionType ?? 'input';
    const renderers = {
        ...actionRenderers,
        ...renderer, // use it after defaults to allow override of existing renderers
    };
    const WaitRenderer = renderers['wait'];
    const ActionRenderer = renderers[actionType];
    const classes = [CSSClasses.botui_action, 'action_' + actionType];
    return (React.createElement("div", { className: CSSClasses.botui_action_container }, action?.type == BOTUI_BLOCK_TYPES.ACTION ? (action?.meta?.waiting ? (React.createElement(WaitRenderer, null)) : ActionRenderer !== undefined ? (React.createElement(WithRefContext, { className: classes.join(' ') },
        React.createElement(SlideFade, null,
            React.createElement(BringIntoView, { bringIntoView: bringIntoView },
                React.createElement(ActionRenderer, null))))) : (`Action renderer not found: ${action?.meta?.actionType}. ${JSON.stringify(action.meta)}`)) : null));
}
//# sourceMappingURL=BotUIAction.js.map